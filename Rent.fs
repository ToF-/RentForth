\ Rent.fs
INCLUDE ffl/hct.fs

10000 CONSTANT MAX-ORDERS
MAX-ORDERS 2* CONSTANT RENT-HCT-SIZE
VARIABLE CURRENT-VALUE
VARIABLE RENT-VALUE
VARIABLE RENT-HCT-VALUES

: RENT-VALUES
    RENT-HCT-VALUES @ ;

: INIT-RENT
    0 RENT-VALUE ! 
    0 CURRENT-VALUE !
    RENT-VALUES ?DUP IF HCT-FREE THEN
    RENT-HCT-SIZE HCT-NEW RENT-HCT-VALUES ! ;

: S>KEY ( n -- addr c )
    S>D <# #S #> ;

: MAX! ( n addr -- )
    DUP @ ROT MAX SWAP ! ;

: END ( s d -- e )
    + ;

: RENT-VALUE#@ ( t -- n )
    S>KEY RENT-VALUES HCT-GET
    0= IF 0 THEN ;

: RENT-VALUE#! ( n t -- )
    S>KEY RENT-VALUES HCT-INSERT ;

: RENT ( s d b -- )
    CURRENT-VALUE @ + 
    DUP RENT-VALUE MAX! 
    -ROT END RENT-VALUE#! ;

: COLLECT ( t -- )
    RENT-VALUE#@ CURRENT-VALUE MAX! ;

1 CONSTANT RENT-CODE
0 CONSTANT COLLECT-CODE 

: ENCODE-RENT ( s d b -- evR )
    ROT 1 LSHIFT RENT-CODE OR
    21 LSHIFT ROT OR
    21 LSHIFT SWAP OR ;

: ENCODE-COLLECT ( s d -- evC )
    + 1 LSHIFT 42 LSHIFT ;

: ORDER>EVENTS ( s d b -- evR evC )
    >R 2DUP R> 
    ENCODE-RENT
    -ROT
    ENCODE-COLLECT ;

: RENT? ( ev -- t|f )
    1 42 LSHIFT AND ;

: DECODE-EVENT { ev -- s d b xRent | s xCollect }
    DUP RENT? IF
        DUP 1 21 LSHIFT 1- AND
        SWAP 21 RSHIFT
        DUP 1 21 LSHIFT 1- AND
        -ROT
        SWAP 22 RSHIFT -ROT 
        ['] RENT
    ELSE
    THEN ;
