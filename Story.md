Rent your Airplane and Make Money
=================================
1.  The request
---------------

Here is what we received:

> "ABEAS Corp." is a very small company that owns a single airplane. The customers
of ABEAS Corp are large airline companies which rent the airplane to accommodate
occasional overcapacity.
>
> Customers send renting orders that consist of a time interval and a price that
the customer is ready to pay for renting the airplane during the given time
period. Orders of all the customers are known in advance. Of course, not all
orders can be accommodated and some orders have to be declined. Eugene LAWLER,
the Chief Scientific Officer of ABEAS Corp would like to maximize the profit of
the company.
>
> You are requested to compute an optimal solution.

There's also a small example:

> Consider for instance the case where the company has 4 orders:
>
> 1.  Order 1 (start time 0, duration 5, price 10)
> 2.  Order 2 (start time 3, duration 7, price 8)
> 3.  Order 3 (start time 5, duration 9, price 7)
> 4.  Order 4 (start time 6, duration 9, price 8)
> 
> The optimal solution consists in declining Order 2 and 3 and the gain is 10+8 =
18. Note that the solution made of Order 1 and 3 is feasible (the airplane is
rented with no interruption from time 0 to time 14) but non-optimal.

The constraints are as follow:

- Number of orders n: n ≤ 10000
- for each order:
    - start time st: 0 ≤ st \< 1000000
    - duration d: 0 \< d \< 1000000
    - price p: 0 \< p \< 100000

2. Finding the formula
----------------------

We can determine the profit of a list of N orders using this formula:

P = maximum {Profit(i,N)..Profit(n,N)} 

where

Profit(i,n) = Price(i) + maximum { Profit(j)..Profit(n) | Start(j) ≥ Start(i)+Duration(i) }

Applied to our example:

     P = maximum { Profit(1,4),Profit(2,4),Profit(3,4),Profit(4,4) }

        Profit(1,4) = 10 + maximum { Profit(3,4),Profit(4,4) }
                    = 10 + maximum { 7 + maximum { }, 8 + maximum { } }
                    = 18
        Profit(2,4) = 14  + maximum { }
        Profit(3,4) = 8  + maximum { }
        Profit(4,4) = 7  + maximum { }

Infortunately this formula is not practical as the computation time of P would be O(N!)

But we know that 

    ∀ t ∈ {Start(1),Start(1)+Duration(1) .. Start(n),Start(n)+Duration(n) }
    P(0) = 0
    P(t) ≥ P(t-1) 
    ∀ t,t' | Order t t' p ⇒ P(t') ≥ P(t)+p  
    
Applied to our example:

    Order 0 5 10 ⇒ P(5) ≥ P(0)+10 ⇒ P(5) ≥ 10
    P(3) ≥ P(0) ⇒ P(3) ≥ 0
    Order 3 7 14 ⇒ P(10) ≥ P(3)+14 ⇒ P(10) ≥ 14
    Order 5 9  8 ⇒ P(14) ≥ P(5)+8 ⇒ P(14) ≥ 18
    P(6) ≥ P(5) ⇒ P(6) ≥ 10
    Order 6 9  7 ⇒ P(15) ≥ P(6)+7 ⇒ P(15) ≥ 17 & P(15) ≥ P(14) ⇒ P(15) ≥ 18 


3 Practical process
-------------------

Here's how we would do given a list of orders:

    0 5 10
    3 7  14
    5 9  8
    6 9  7

 and a calendar:

      0   1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
      +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
      |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |

First, we list all the events generated by the orders, ordered by time:

    at time 0 plan to rent until 5 for P[0] + 10 
    at time 3 plan to rent until 10 for P[3] + 14
    at time 5 evaluate cash
    at time 5 plan to rent until 14 for P[5] + 8
    at time 6 plan to rent until 15 for P[6] + 7
    at time 10 evaluate cash
    at time 14 evaluate cash
    at time 15 evaluate cash

at time 0 plan to rent until 5 for P[0] + 10 

       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20    P
      | 0|  |  |  |  |10|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  0  

at time 3 plan to rent until 10 for P[3] + 14

       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20    P
      | 0|  |  | 0|  |10|  |  |  |  |14|  |  |  |  |  |  |  |  |  |  |  0

at time 5 evaluate cash

       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20    P
      | 0|  |  | 0|  |10|  |  |  |  |14|  |  |  |  |  |  |  |  |  |  | 10

at time 5 plan to rent until 14 for P[5] + 8

       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20    P
      | 0|  |  | 0|  |10|  |  |  |  |14|  |  |  |18|  |  |  |  |  |  | 10

at time 6 plan to rent until 15 for P[6] + 7

       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20    P
      | 0|  |  | 0|  |10|10|  |  |  |14|  |  |  |18|17|  |  |  |  |  | 10

at time 10 evaluate cash

       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20    P
      | 0|  |  | 0|  |10|10|  |  |  |14|  |  |  |18|17|  |  |  |  |  | 14

at time 14 evaluate cash

       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20    P
      | 0|  |  | 0|  |10|10|  |  |  |14|  |  |  |18|17|  |  |  |  |  | 18

at time 15 evaluate cash

       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20    P
      | 0|  |  | 0|  |10|10|  |  |  |14|  |  |  |18|18|  |  |  |  |  | 18

 
4. A first, partial implementation
----------------------------------

We need a variable to store the current profit, and an array to store the plan. We will limit the capacity to 100 time slots, from 0 to 99.

    VARIABLE PROFIT 

Given that in gforth, a cell is 8 bytes long, the phrase 

    CREATE PLAN 100 CELLS ALLOT

will reserve 800 bytes for an array named PLAN. The following word erases the array and set the value to zero.


    : INITIALIZE
        PLAN 100 CELLS ERASE
        0 PROFIT ! ;

To access to one of the time slots in the array, we calculate its address this way:

    : PLAN# ( time -- addr )
        CELLS PLAN + ;

Reading a value in the plan at a given time, we should either get that value, or the current profit if the profit is greater. That is because we will be processing actions in order, meaning that at each time, before we "rent" we have evaluated the profit. 

    : PLAN@ ( time -- n  )
        PLAN# @ PROFIT @ MAX ;
 
Updating the plan a at time zone is done only with a value greater or equal than the current value for the time.

    : PLAN! ( n time -- )
        PLAN# DUP @ ROT MAX SWAP ! ;
 
When we evaluate the cash at a time, we update the profit with the value in the plan at that time if it's greater.

    : CASH ( time -- )
        PLAN@ PROFIT ! ;

Finally, when we plan a rent at a given time, we take the current profit, add the price of the order, and update the plan at that time if it's greater.

    : RENT ( end price -- )
        PROFIT @ + SWAP PLAN! ;
    
Let's try our little program. The following test shows that the rent value of 18 is correctly computed:

    \ Tests.fs
    REQUIRE ffl/tst.fs
    REQUIRE Rent.fs

    : TEST-PROCESSING-ACTIONS
        INITIALIZE
        5  10 RENT
        10 14 RENT
        5 CASH
        14 8 RENT
        15 7 RENT
        10 CASH
        14 CASH
        15 CASH
        T{ PROFIT @ 18 ?S }T ; 
        

    TEST-PROCESSING-ACTIONS
    BYE

Such a simple program :-)

    \ Rent.fs

    VARIABLE PROFIT 
    CREATE PLAN 100 CELLS ALLOT

    : INITIALIZE
        PLAN 100 CELLS ERASE
        0 PROFIT ! ;

    : PLAN# ( time -- addr )
        CELLS PLAN + ;

    : PLAN@ ( time -- n  )
        PLAN# @ PROFIT @ MAX ;
     
    : PLAN! ( n time -- )
        PLAN# DUP @ ROT MAX SWAP ! ;
     
    : CASH ( time -- )
        PLAN@ PROFIT ! ;
          
    : RENT ( end price -- )
        PROFIT @ + SWAP PLAN! ;

5. Reality
----------
There is a problem with our approach: 
        
> - Number of orders n: n ≤ 10000
> - for each order:
>     - start time st: 0 ≤ st \< 1000000
>     - duration d: 0 \< d \< 1000000
>     - price p: 0 \< p \< 100000

Creating an array of 2000000 cells to store 10000 distinct values is not efficient. A better idea woud be to use a [hash table](http://irdvo.github.io/ffl/docs/hct.html). The library ffl offers such a thing. Here's how to use it:

    require ffl/hct.fs
    100 hct-create rivers 
    6853 s" Niles"  rivers hct-insert   
    6992 s" Amazon" rivers hct-insert  
    1233 s" Rhine"  rivers hct-insert  

    s" Niles" rivers hct-get cr . .
    -1 6853  ok

    s" Seine" rivers hct-get cr . 
    0  ok

As the hashtable associate data (a cell) with a string, we need to convert the time value into a string before inserting values into or getting values from the hashtable. The way to do this is to use the traditionnal forth words: 

    : INT>STRING ( n -- addr # )
        S>D <# #S #> ;
    
    4807 17 * INT>STRING DUMP
    10F885E3D: 38 31 37 31  39          -                           81719

Let's implement this. First we need to create a hast table rather than an array:

    10000 CONSTANT MAXORDER#
    MAXORDER# HCT-CREATE PLAN

Our initialization word with (re-)init the plan as well:

    : INITIALIZE
        MAXORDER# PLAN HCT-INIT
        0 PROFIT ! ;

Access to a value of the plan is still done with `PLAN#`, but now this word's job is to convert the time value into a string and push the hashtable on the stack, ready for `HCT-GET` or `HCT-INSERT` to operate:

    : INT>STR ( n -- addr # )
        S>D <# #S #> ;

    : PLAN# ( time -- addr # plan )
       INT>STR PLAN ; 

Now looking for a value in the plan is done via `HCT-GET` with a verification of the flag, pushing zero if it's false. 

    : PLAN@ ( time -- n  )
        PLAN# HCT-GET 0= IF 0 THEN PROFIT @ MAX ;

Inserting a value in the plan is done almost in the same way than before:


    : PLAN! ( n time -- )
        DUP PLAN@ ROT MAX SWAP PLAN# HCT-INSERT ;

And the main words `CASH` and `RENT` are not modified.


