# 1.  The request

Here is what we received:

> "ABEAS Corp." is a very small company that owns a single airplane. The customers
of ABEAS Corp are large airline companies which rent the airplane to accommodate
occasional overcapacity.
>
> Customers send renting orders that consist of a time interval and a price that
the customer is ready to pay for renting the airplane during the given time
period. Orders of all the customers are known in advance. Of course, not all
orders can be accommodated and some orders have to be declined. Eugene LAWLER,
the Chief Scientific Officer of ABEAS Corp would like to maximize the profit of
the company.
>
> You are requested to compute an optimal solution.

There's also a small example:

> Consider for instance the case where the company has 4 orders:
>
> 1.  Order 1 (start time 0, duration 5, price 10)
> 2.  Order 2 (start time 3, duration 7, price 8)
> 3.  Order 3 (start time 5, duration 9, price 7)
> 4.  Order 4 (start time 6, duration 9, price 8)
> 
> The optimal solution consists in declining Order 2 and 3 and the gain is 10+8 =
18. Note that the solution made of Order 1 and 3 is feasible (the airplane is
rented with no interruption from time 0 to time 14) but non-optimal.

The constraints are as follow:

- Number of orders n: n ≤ 10000
- for each order:
    - start time st: 0 ≤ st \< 1000000
    - duration d: 0 \< d \< 1000000
    - price p: 0 \< p \< 100000

#2. Finding the formula

We can determine the rent value of a list of N orders using this formula:

RV = maximum {Value(i,N)..Value(n,N)} 

where

Value(i,n) = Price(i) + maximum { Value(j)..Value(n) | Start(j) ≥ Start(i)+Duration(i) }

Applied to our example:

    RV = maximum { Value(1,4),Value(2,4),Value(3,4),Value(4,4) }

        Value(1,4) = 10 + maximum { Value(3,4),Value(4,4) }
                   = 10 + maximum { 7 + maximum { }, 8 + maximum { } }
                   = 18
        Value(2,4) = 14  + maximum { }
        Value(3,4) = 8  + maximum { }
        Value(4,4) = 7  + maximum { }

Infortunately this formula is not practical as the computation time of RV would be O(N!)

But we know that 

    ∀t ∈ {Start(1),Start(1)+Duration(1) .. Start(n),Start(n)+Duration(n) }
    V(0) = 0
    V(t) ≥ V(t-1) 
    ∀ t,t' | Order t t' p ⇒ V(t') ≥ V(t)+p  
    
Applied to our example:

    ∀ V(t) | t ∈ {0,3,5,6,10,14,15}
    Order 0 5 10 ⇒ V(5) ≥ V(0)+10 ⇒ V(5) ≥ 10
    V(3) ≥ V(0) ⇒ V(3) ≥ 0
    Order 3 7 14 ⇒ V(10) ≥ V(3)+14 ⇒ V(10) ≥ 14
    Order 5 9  8 ⇒ V(14) ≥ V(5)+8 ⇒ V(14) ≥ 18
    V(6) ≥ V(5) ⇒ V(6) ≥ 10
    Order 6 9  7 ⇒ V(15) ≥ V(6)+7 ⇒ V(15) ≥ 17 & V(15) ≥ V(14) ⇒ V(15) ≥ 18 


#3 Practical process

Here's how we would do given a list of orders:

    0 5 10
    3 7  14
    5 9  8
    6 9  7

 and a calendar:

      0   1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
      +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
      |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |

First, we list all the events generated by the orders, ordered by time:

    at time 0 plan to rent until 5 for V[0] + 10 
    at time 3 plan to rent until 10 for V[3] + 14
    at time 5 evaluate cash
    at time 5 plan to rent until 14 for V[5] + 8
    at time 6 plan to rent until 15 for V[6] + 7
    at time 10 evaluate cash
    at time 14 evaluate cash
    at time 15 evaluate cash

at time 0 plan to rent until 5 for V[0] + 10 

       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20    V
      | 0|  |  |  |  |10|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  0  

at time 3 plan to rent until 10 for V[3] + 14

       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20    V
      | 0|  |  | 0|  |10|  |  |  |  |14|  |  |  |  |  |  |  |  |  |  |  0

at time 5 evaluate cash

       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20    V
      | 0|  |  | 0|  |10|  |  |  |  |14|  |  |  |  |  |  |  |  |  |  | 10

at time 5 plan to rent until 14 for V[5] + 8

       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20    V
      | 0|  |  | 0|  |10|  |  |  |  |14|  |  |  |18|  |  |  |  |  |  | 10

at time 6 plan to rent until 15 for V[6] + 7

       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20    V
      | 0|  |  | 0|  |10|10|  |  |  |14|  |  |  |18|17|  |  |  |  |  | 10

at time 10 evaluate cash

       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20    V
      | 0|  |  | 0|  |10|10|  |  |  |14|  |  |  |18|17|  |  |  |  |  | 14

at time 14 evaluate cash

       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20    V
      | 0|  |  | 0|  |10|10|  |  |  |14|  |  |  |18|17|  |  |  |  |  | 18

at time 15 evaluate cash

       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20    V
      | 0|  |  | 0|  |10|10|  |  |  |14|  |  |  |18|18|  |  |  |  |  | 18

 
#4. A first implementation

We need a variable to store the current rent value, and an array to store the plan. We will limit the capacity to 100 time slots, from 0 to 99.

    VARIABLE RENT-VALUE 

Given that in gforth, a cell is 8 bytes long, the phrase 

    CREATE PLAN 100 CELLS ALLOT

will reserve 800 bytes for an array named PLAN. The following word erases the array and set the value to zero.


    : INITIALIZE
        PLAN 100 CELLS ERASE
        0 RENT-VALUE ! ;

To access to one of the time slots in the array, we calculate its address this way:

    : PLAN# ( time -- addr )
        CELLS PLAN + ;

Reading a value in the plan at a given time, we should either get that value, or the current rent value if the current value is greater. That is because we will be processing actions in order, meaning that at each time, before we "rent" we have evaluated the current value. 

    : PLAN@ ( time -- n  )
        PLAN# @ RENT-VALUE @ MAX ;
 
Writing a value in the plan should never diminish the value at that time if it was already set to a greater value.

    : PLAN! ( n time -- )
        PLAN# DUP @ ROT MAX SWAP ! w
 
When we evaluate the cash at a time, we update the current value wtih the value in the plan at that time if it's greater.

    : CASH ( time -- )
        PLAN@ RENT-VALUE ! ;

Finally, when we plan a rent at a given time, we take the current rent value, add the price of the order, and update the plan at that time if it's greater.

    : RENT ( end price -- )
        RENT-VALUE @ + SWAP PLAN! ;
    
Let's try our little program. The following test shows that the rent value of 18 is correctly computed:

    \ Tests.fs
    REQUIRE ffl/tst.fs
    REQUIRE Rent.fs

    : TEST-PROCESSING-ACTIONS
        INITIALIZE
        5  10 RENT
        10 14 RENT
        5 CASH
        14 8 RENT
        15 7 RENT
        10 CASH
        14 CASH
        15 CASH
        T{ RENT-VALUE @ 18 ?S }T ; 
        

    TEST-PROCESSING-ACTIONS
    BYE

Such a simple program :-)

    \ Rent.fs

    VARIABLE RENT-VALUE 
    CREATE PLAN 100 CELLS ALLOT

    : INITIALIZE
        PLAN 100 CELLS ERASE
        0 RENT-VALUE ! ;

    : PLAN# ( time -- addr )
        CELLS PLAN + ;

    : PLAN@ ( time -- n  )
        PLAN# @ RENT-VALUE @ MAX ;
     
    : PLAN! ( n time -- )
        PLAN# DUP @ ROT MAX SWAP ! ;
     
    : CASH ( time -- )
        PLAN@ RENT-VALUE ! ;
          
    : RENT ( end price -- )
        RENT-VALUE @ + SWAP PLAN! ;
        
